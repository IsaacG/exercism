Generic
-------

Using a function() is good practice; it encapsulates a chunk of logic in one function which is good practice for when things get bigger.

What happens if you were to add `set -o nounset` to your code and call it without any args?

For arithmetic operations (numbers), prefer `((` over `[[`. `((` is an arithmetic operation while `[[` is used for strings.

Note you moved your logic out of main(). Generally, main() should contain all your logic.

In bash, prefer `[[` over `[`. It's more powerful and less likely to act in unexpected ways.

You got a lot of boilerplate comments left in there that would be nice to drop. It makes it harder to find your code.

Prefer to avoid using `exit` inside a function! Use `return 0` in case something else runs after calling this function.

In bash, prefer `[[` over `[`. It's more powerful and less likely to act in unexpected ways. **However** for arithmetic operations (numbers ie *here*), prefer `((` over `[[`. `((` is an arithmetic operation while `[[` is used for strings.

You seem to have lost your shebang on the top line. This means if you `chmod +x` your script, you can't control what shell is used to run it!

You got a number of unquoted variable expansions that ought to get fixed.

You got an odd mix of [ and $(( going on. In bash, you can use [[ for strings and (( for numbers. `if (( $n % 3 == 0 )); then ...`

In bash, prefer [[ over [. It's more powerful and less likely to act in unexpected ways.

Note the most portable way (and common way) to define a function is without the `function` keyword. eg `main () { ...`

Avoid using all-caps variable names. Those are used by the shell for internal things like PWD and SECONDS. Overriding them can lead to odd behaviors.

Can you use a pattern over a regex here? Patterns tend to be simpler and cheaper to use. Simpler solutions tend to be better than more complex ones.

Note other ways to do accumulations include `(( sum += n ))` and `declare -i sum=1; sum+=n`.

Note that `echo $(something) == something` and `a=$(echo b) == a=b`.

`seq` is a non-standard tool that can output anything (eg "one two three"). It's also an external binary which isn't needed when bash can do the job itself! Prefer `for ((i = 1; i <= 10; i++)); do`

Don't forget to quote your variable expansions!

Other accumulator options: `local -i total; total+=1;` and `(( total += 1 ))`. Pick whichever looks the nicest to you.

Typically people put the `if`|`for` and `then`|`do` on the same line. `if ...; then` and `for ...; do`

Hello World
-----------

Can you solve this in a way that doesn't have a mostly duplicated output string? Duplication in code is a hassle to maintain as any change needs to be applied across multiple locations.

On LN you have an unquoted variable! That can lead to unexpected behavior.
$  bash ./two_fer.sh "a -o -n a"


Raindrops
---------

Interestingly, you quoted the strings `Pl?ng` (which don't actually benefit much from it) but failed to quote your variable expansion. Variable expansions should *always* be quoted.

Consider what would happen if you ran the command below. Can you fix that echo line somehow?
```
$ bash raindrops.sh "-e foo"
```


Leap
----

You got a lot of logic in your test. Can you split the logic across multiple statements?

Your code doesn't let me check if year 600 and 800 are leap years :(

LN got a messy combination of `[[` and `((` and `$((`. You should be able to solve this with just `((` and without any nesting.


Reverse
-------

What happens here and can you fix it without breaking the logic? `$ bash reverse.sh 'bor\ed e-'


Grains
------

- Can you solve this without resorting to external tools like `bc`?
