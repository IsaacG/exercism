Generic
-------

Using a function() is good practice; it encapsulates a chunk of logic in one function which is good practice for when things get bigger.

What happens if you were to add `set -o nounset` to your code and call it without any args?

For arithmetic operations, prefer (( over [[. (( is an arithmetic operation while [[ is used for strings.

Note you moved your logic out of main(). Generally, main() should contain all your logic.

In bash, prefer [[ over [. It's more powerful and less likely to act in unexpected ways.

You got a lot of boilerplate comments left in there that would be nice to drop. It makes it harder to find your code.

Prefer to avoid using `exit` inside a function! Use `return 0` in case something else runs after calling this function.

In bash, prefer [[ over [. It's more powerful and less likely to act in unexpected ways. **However** for arithmetic operations, prefer (( over [[. (( is an arithmetic operation while [[ is used for strings.

You seem to have lost your shebang on the top line. This means if you `chmod +x` your script, you can't control what shell is used to run it!

You got a number of unquoted variable expansions that ought to get fixed.

You got an odd mix of [ and $(( going on. In bash, you can use [[ for strings and (( for numbers. `if (( $n % 3 == 0 )); then ...`

In bash, prefer [[ over [. It's more powerful and less likely to act in unexpected ways.

Note the most portable way (and common way) to define a function is without the `function` keyword. eg `main () { ...`

Avoid using all-caps variable names. Those are used by the shell for internal things like PWD and SECONDS. Overriding them can lead to odd behaviors.

Can you use a pattern over a regex here? Patterns tend to be simpler and cheaper to use. Simpler solutions tend to be better than more complex ones.

Note other ways to do accumulations include `(( sum += n ))` and `declare -i sum=1; sum+=n`.

Hello World
-----------

I decided I want two for me every time I give one away. Can you change the code so that you only need to edit the string ("one for me") once whenever you want to update it?

On LN you have an unquoted variable! That can lead to unexpected behavior.
$  bash ./two_fer.sh "a -o -n a"


Raindrops
---------

Interestingly, you quoted the strings `Pl?ng` (which don't actually benefit much from it) but failed to quote your variable expansion. Variable expansions should *always* be quoted.

Consider what would happen if you ran the command below. Can you fix that echo line somehow?
```
$ bash raindrops.sh "-e foo"
```


Leap
----

You got a lot of logic in your test. Can you split the logic across multiple statements?

Your code doesn't let me check if year 600 and 800 are leap years :(

LN got a messy combination of `[[` and `((` and `$((`. You should be able to solve this with just `((` and without any nesting.


Reverse
-------

What happens here and can you fix it without breaking the logic? `$ bash reverse.sh 'bor\ed e-'
