
Raindrops
---------
From a scalability perspective, can you solve this in a way that doesn't mean repeating a bunch of code for every sound/factor?
From a scalability perspective, can you avoid the (relatively) costly repeated string-append (which has to copy the entire string every time)?


Matrix
------
You might want to use a linter. Typically, the `[` and `]` are not padded with spaces.
If a Matrix is constructed once then a bunch of rows and columns are read, this would convert the elements to `int()` many times. Moving that conversion to `__init__` allows you to do that just once. Additionally, if there's a non-int value, it's nice to catch it early and up front.
Python provides a [`str.splitlines`](https://docs.python.org/3/library/stdtypes.html#str.splitlines) method that you may want to consider using.
Do you need to specify a separator for your per-line [`str.split`](https://docs.python.org/3/library/stdtypes.html#str.split) call?
Fun fact. If someone does: `matrix.row(3)[0] = 5`, this will alter the data stored in the matrix. Conversely, if they did `matrix.column(3)[0] = 5`, this would *not* update the matrix. Something to think about :)
Which of these do you find easier to read? `[int(i) for i in mylist]` or `list(map(int, mylist))`?
This solution maintains two copies of the data. If the data is large, that can be expensive. Can you solve this without maintaining two copies of the data?
Could a list comprehension by used for `column()`?
In general, if you're ranging over an index in Python, you're doing something wrong. Consider ranging over the elements of the list (and using `results.append()`) or a list comprehension.
